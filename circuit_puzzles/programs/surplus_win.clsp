; This program is used to claim the surplus auction win
; If last bid goes over TTL, it's a win.  Running this operation burns the CRT locked into this coin (surplus auction)
; and unlocks BYC in payout coin and sends them to the winning target puzzle hash.
(mod
  (
    (MOD_HASH CAT_MOD_HASH STATUTES_STRUCT BYC_TAIL_HASH CRT_TAIL_HASH LAUNCHER_ID BID_TTL MIN_BID_INCREASE_BPS BYC_LOT_AMOUNT LAST_BID)
    statutes_inner_puzzle_hash lineage_proof input_conditions
    (
      current_timestamp
      crt_tail_puzzle
      payout_coin_parent_id
      payout_mod_hash
      approval_mod_hashes
    )
  )

  (include *standard-cl-23.1*)
  (include curry.clib)
  (include condition_codes.clib)
  (include statutes_utils.clib)
  (include utils.clib)

  (assign
    statutes_puzzle_hash (calculate-statutes-puzzle-hash STATUTES_STRUCT statutes_inner_puzzle_hash)
    (target_puzzle_hash . timestamp) LAST_BID
    crt_tail_hash (sha256tree crt_tail_puzzle)
    payout_puzzle_hash (
      curry_hashes CAT_MOD_HASH
        (sha256 ONE CAT_MOD_HASH)
        (sha256 ONE BYC_TAIL_HASH)
        (curry_hashes payout_mod_hash
          (sha256 ONE payout_mod_hash)
          (sha256 ONE CRT_TAIL_HASH)
          (sha256 ONE LAUNCHER_ID)
        )
    )
    payout_coin_id (calculate-coin-id
        payout_coin_parent_id
        payout_puzzle_hash
        BYC_LOT_AMOUNT
    )
    (assert
      (size_b32 payout_mod_hash)
      ; ensure correct tail reveal is passed
      (= crt_tail_hash CRT_TAIL_HASH)
      ; must have a bid
      LAST_BID
      ; ttl for last bid should've expired
      (> (- current_timestamp timestamp) BID_TTL)
      (li
        ; no recreate here, we create melting condition
        ; not asserting my puzzle hash and my amount in present puzzle as crt tail does this on melt
        (list CREATE_COIN 0 -113 crt_tail_puzzle
          ; construct limitation solution
          (list
            "x"
            MOD_HASH
            BYC_TAIL_HASH
            CRT_TAIL_HASH
            LAUNCHER_ID
            BID_TTL
            MIN_BID_INCREASE_BPS
            BYC_LOT_AMOUNT
            LAST_BID
            statutes_inner_puzzle_hash
            approval_mod_hashes
          )
        )
        (assert-statute statutes_puzzle_hash STATUTE_PAYOUT_MOD_HASH payout_mod_hash)
        ; current_time minus one tx block time should already be in the past
        (list ASSERT_SECONDS_ABSOLUTE (- current_timestamp MAX_TX_BLOCK_TIME))
        ; make sure that current_timestamp hasn't happen yet, allow it to be in mempool for 5 tx blocks
        (list ASSERT_BEFORE_SECONDS_ABSOLUTE (+ current_timestamp (* 5 MAX_TX_BLOCK_TIME)))
        ; assert payout coin transferred the lot amount to the winner (target_puzzle_hash)
        (list SEND_MESSAGE 0x3f
          (concat
            PROTOCOL_PREFIX
            (sha256tree (c BYC_LOT_AMOUNT (c target_puzzle_hash LAUNCHER_ID)))
          )
          payout_coin_id
        )
        ; ensure lineage so nobody can fake the winning bid, ie nobody can fake this state transition (CREATE_COIN conditions are not allowed, so siblings are not possible)
        (list ASSERT_MY_PARENT_ID
          (calculate-coin-id
            (f lineage_proof)
            (curry_hashes
              CAT_MOD_HASH
              (sha256 ONE CAT_MOD_HASH)
              (sha256 ONE CRT_TAIL_HASH)
              (tree_hash_of_apply MOD_HASH (f (r (r lineage_proof))))
            )
            ; parent bid amount
            (f (r lineage_proof))
          )
        )
        &rest
        input_conditions
      )
    )
  )
)