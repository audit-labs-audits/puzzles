(mod (
      CAT_MOD_HASH BYC_TAIL_MOD_HASH
      MOD_HASH
      STATUTES_STRUCT LAUNCHER_ID RING_PREV_LAUNCHER_ID
      ; lineage proof is:
      ; -> () at launch. this mod enforces launch to be a change ring ordering operation
      ; -> (parent_parent_id parent_ring_prev_launcher_id parent_amount) otherwise 
      lineage_proof 
      statutes_inner_puzzle_hash current_amount
      input_conditions
      ; args are:
      ; -> new_ring_prev_launcher_id when changing ring ordering. i.e solution is a struct
      ; -> (approver_parent_id approver_mod_hash approver_mod_curried_args_hash approver_amount approval_mod_hashes new_amount) when spending. i.e. solution is a list
      . args 
    )

  (include *standard-cl-23.1*)
  (include curry.clib)
  (include condition_codes.clib)
  (include condition_filtering.clib)
  (include statutes_utils.clib)
  (include utils.clib)

  ; anything that isn't a protocol condition is allowed
  (defun filter-conditions ((@ conditions ((condition_code . condition_body) . rest_of_conditions)) filtered_conditions)
    (if conditions
      (if (= condition_code REMARK)
        (assert
          (is-valid-rmk-cond condition_body)
          (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
        )
        (if (any (= condition_code SEND_MESSAGE) (= condition_code RECEIVE_MESSAGE))
          (assert
            (is-valid-msg-cond condition_body)
            (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
          )
          (if (any (= condition_code CREATE_COIN_ANNOUNCEMENT) (= condition_code CREATE_PUZZLE_ANNOUNCEMENT))
            (assert
              (is-valid-ann-cond condition_body)
              (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
            )
            ; all other conditions allowed
            (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
          )
        )
      )
      filtered_conditions
    )
  )

  ; parse CREATE_COIN conditions passed in via solution (input_conditions) plus create_child_condition generated by this puzzle
  ; ensures that there is exactly one CREATE_COIN condition with same puzzle hash as create_child_condition
  ; allows any number of child coins to be created that have a different puzzle hash to that of create_child_condition
  (defun parse-conditions (input_conditions new_puzzle_hash my_create_coin_exists return_conditions withdraw_amount)
    (if (l input_conditions)
      (assign
        (condition_code condition_body . rest_condition) (f input_conditions)
        (if (= condition_code CREATE_COIN)
          (if condition_body
            (if (= condition_body new_puzzle_hash)
              ; if it's paying into our puzzle hash, increase the sum (they're depositing)
              (if my_create_coin_exists
                (x) ; can't pay into our own puzzle hash twice, i.e. at most one treasury child coin allowed
                (parse-conditions (r input_conditions) new_puzzle_hash ONE (c (f input_conditions) return_conditions) withdraw_amount)
              )
              ; if it's paying into a different puzzle hash, decrease the sum (they're withdrawing)
              (parse-conditions (r input_conditions) new_puzzle_hash my_create_coin_exists (c (f input_conditions) return_conditions) (+ withdraw_amount (f rest_condition)))
            )
            (parse-conditions (r input_conditions) new_puzzle_hash my_create_coin_exists (c (f input_conditions) return_conditions) withdraw_amount)
          )
          (parse-conditions (r input_conditions) new_puzzle_hash my_create_coin_exists (c (f input_conditions) return_conditions) withdraw_amount)
        )
      )
      ; all done, return sum and enforce our create coin condition
      (assert
        my_create_coin_exists ; must create at least one coin with same inner puzzle hash as existing treasury coin, i.e. create at least one child treasury coin
        (list withdraw_amount return_conditions)
      )
    )
  )

  (assign
    filtered_conditions (filter-conditions input_conditions ())
    statutes_puzzle_hash (calculate-statutes-puzzle-hash STATUTES_STRUCT statutes_inner_puzzle_hash)
    statutes_struct_hash (sha256tree STATUTES_STRUCT)
    byc_tail_hash (curry_hashes BYC_TAIL_MOD_HASH statutes_struct_hash)
    ; 1. we're withdrawing/depositing/announcing, lineage proof is parent_id of parent coin and amount, we need to assert
    ;    that assert_parent_id is `(parent_id . previous_amount)`
    ; 2. we're changing lineage, lineage proof is `(parent_id . prev_launcher_id)` and
    ;    asserts announcement from statutes vote
    new_puzzle_hash (curry_hashes MOD_HASH ; inner puzzle hash
                      (sha256 ONE MOD_HASH)
                      statutes_struct_hash
                      (sha256 ONE LAUNCHER_ID)
                      (if (any (not (l args)) (not lineage_proof)) ; (= (f lineage_proof) LAUNCHER_ID))
                        ; we're changing ring ordering
                        (sha256 ONE args) ; new ring_prev_launcher_id
                        ; we're spending/announcing
                        (sha256 ONE RING_PREV_LAUNCHER_ID)
                      )
                    )
    parent_id (if (not lineage_proof) ; (= (f lineage_proof) LAUNCHER_ID)
      ; this is eve spend, assert launcher id
      LAUNCHER_ID
      ; non-eve spend, assert parent id
      (calculate-coin-id
        (f lineage_proof) ; parent parent id
        (curry_hashes CAT_MOD_HASH
          (sha256 ONE CAT_MOD_HASH)
          (sha256 ONE byc_tail_hash)
          (curry_hashes MOD_HASH ; puzzle hash
            (sha256 ONE MOD_HASH)
            statutes_struct_hash
            (sha256 ONE LAUNCHER_ID)
            (sha256 ONE (f (r lineage_proof))) ; parent ring_prev_launcher_id
          )
        )
        (f (r (r lineage_proof))) ; parent amount
      )
    )
    new_amount (if (l args)
      (f (r (r (r (r (r args))))))
      current_amount
    )
    ; create child treasury coin singleton
    create_child_condition (list CREATE_COIN new_puzzle_hash new_amount)
    (
      withdraw_amount_pre
      conditions
    ) (parse-conditions
        (c create_child_condition filtered_conditions)
        new_puzzle_hash
        0 ; my create coin exists = false. 
        () ; return_conditions
        0 ; init withdraw_amount = 0
      )
    withdraw_amount (
      if (> current_amount new_amount)
          (- current_amount new_amount)
        withdraw_amount_pre
    )
    (assert
     (> withdraw_amount_pre MINUS_ONE)
     (> current_amount (- withdraw_amount_pre ONE))
     ; can't go into negative
     (> new_amount MINUS_ONE) (> withdraw_amount MINUS_ONE)
     (any
      ; we can't leave any change if withdrawing
      (= current_amount (+ new_amount withdraw_amount))
      ; or if depositing must be higher than previous value
      (all (= withdraw_amount 0) (> new_amount current_amount))
     )
     ; we can't do both a withdrawal and a deposit at the same time
     (not (all (> withdraw_amount 0) (> new_amount current_amount)))
     ; must have at least one condition
     (l conditions)
     ; ---- all asserts passed, return conditions
      (c
        (list ASSERT_MY_AMOUNT current_amount)
        (c
          (list ASSERT_MY_PARENT_ID parent_id)
          (if (any (not (l args)) (not lineage_proof)) ; (= (f lineage_proof) LAUNCHER_ID))
            ; change ring ordering, require approval from statutes
            (assert
              (= withdraw_amount 0)
              (size_b32 args)
              (c
                (list RECEIVE_MESSAGE 0x12
                  (concat
                    PROTOCOL_PREFIX
                    CUSTOM_CONDITION_PREFIX
                    (sha256tree
                      (c LAUNCHER_ID
                        args ; new ring_prev_launcher_id
                      )
                    )
                  )
                  statutes_puzzle_hash
                )
                (c
                  (list REMARK PROTOCOL_PREFIX new_amount LAUNCHER_ID args) ; for driver code
                  conditions
                )
              )
            )
            ; ELSE we're spending/announcing, require approval mods
            (assign
              (
                approver_parent_id
                approver_mod_hash
                approver_mod_curried_args_hash
                approver_amount
                approval_mod_hashes
                _ ; new_amount extracted above
              ) args
              approver_coin_id (assert
                (size_b32 approver_parent_id)
                (size_b32 approver_mod_hash)
                (size_uint64 approver_amount)
                ; check that this approver mod hash is allowed
                (contains approval_mod_hashes approver_mod_hash)
                (calculate-coin-id
                  approver_parent_id
                  ; we want to ensure that the approver puzzle is using the correct mod
                  (if (l approver_mod_curried_args_hash)
                    ; this puzzle is wrapped inside a CAT puzzle, it'll provide a tail too
                    (assert
                      (= (f approver_mod_curried_args_hash) CAT_MOD_HASH)
                      (size_b32 (f (r (r approver_mod_curried_args_hash))))
                      (size_b32 (f (r approver_mod_curried_args_hash)))
                      (curry_hashes CAT_MOD_HASH
                        (sha256 ONE CAT_MOD_HASH)
                        (sha256 ONE (f (r approver_mod_curried_args_hash)))
                        (tree_hash_of_apply approver_mod_hash (f (r (r approver_mod_curried_args_hash))))
                      )
                    )
                    ; ELSE puzzle is not wrapped
                    (assert (size_b32 approver_mod_curried_args_hash)
                      (tree_hash_of_apply approver_mod_hash approver_mod_curried_args_hash)
                    )
                  )
                  approver_amount
                )
              )
    
              (c
                ; assert approver coin announcement is valid
                (list RECEIVE_MESSAGE 0x3f
                  (concat
                    PROTOCOL_PREFIX
                    (sha256tree (c (- new_amount current_amount) new_amount))
                  )
                  approver_coin_id
                )
                ; assert that approval mod hashes are valid
                (c (assert-statute statutes_puzzle_hash STATUTE_APPROVAL_MOD_HASHES_HASH (sha256tree approval_mod_hashes))
                  (c
                    ;  my new balance so someone can check whole ring balance
                    (list CREATE_COIN_ANNOUNCEMENT
                      (concat
                        PROTOCOL_PREFIX
                        (sha256tree (c new_amount LAUNCHER_ID))
                      )
                    )
                    (c
                      (list REMARK PROTOCOL_PREFIX new_amount LAUNCHER_ID RING_PREV_LAUNCHER_ID) ; for driver code
                      conditions
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
