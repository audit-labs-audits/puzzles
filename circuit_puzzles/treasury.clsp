(mod (
      CAT_MOD_HASH BYC_TAIL_MOD_HASH MOD_HASH
      STATUTES_STRUCT LAUNCHER_ID RING_PREV_LAUNCHER_ID
      ; lineage proof is:
      ; -> () at launch (enforced to be a change ring ordering spend)
      ; -> (parent_parent_id parent_ring_prev_launcher_id) if ring ordering changed after launch
      ; -> (parent_parent_id . parent_amount) if balance changed
      lineage_proof 
      statutes_inner_puzzle_hash current_amount
      input_conditions
      ; args are:
      ; -> new_ring_prev_launcher_id when changing ring ordering. i.e solution is a struct
      ; -> (approver_parent_id approver_mod_hash approver_mod_curried_args_hash approver_amount approval_mod_hashes new_amount) when spending. i.e. solution is a list
      . args 
    )

  (include *standard-cl-23.1*)
  (include curry.clib)
  (include condition_codes.clib)
  (include condition_filtering.clib)
  (include statutes_utils.clib)
  (include utils.clib)

  ; anything that isn't a create coin or protocol condition is allowed
  (defun filter-conditions ((@ conditions ((condition_code . condition_body) . rest_of_conditions)) filtered_conditions)
    (if conditions
      (if (= condition_code CREATE_COIN)
        ; create coin only allowed with magic amount for melting
        (if (= (f (r condition_body)) -113)
          (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
          (x)
        )
        (if (= condition_code REMARK)
          (assert
            (is-valid-rmk-cond condition_body)
            (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
          )
          (if (any (= condition_code SEND_MESSAGE) (= condition_code RECEIVE_MESSAGE))
            (assert
              (is-valid-msg-cond condition_body)
              (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
            )
            (if (any (= condition_code CREATE_COIN_ANNOUNCEMENT) (= condition_code CREATE_PUZZLE_ANNOUNCEMENT))
              (assert
                (is-valid-ann-cond condition_body)
                (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
              )
              ; all other conditions allowed
              (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
            )
          )
        )
      )
      filtered_conditions
    )
  )


  (assign
    filtered_conditions (filter-conditions input_conditions ())
    statutes_puzzle_hash (calculate-statutes-puzzle-hash STATUTES_STRUCT statutes_inner_puzzle_hash)
    statutes_struct_hash (sha256tree STATUTES_STRUCT)
    byc_tail_hash (curry_hashes BYC_TAIL_MOD_HASH statutes_struct_hash)
    new_puzzle_hash (curry_hashes MOD_HASH
                      (sha256 ONE MOD_HASH)
                      statutes_struct_hash
                      (sha256 ONE LAUNCHER_ID)
                      (if (any (not (l args)) (not lineage_proof))
                        ; we're changing ring ordering
                        (sha256 ONE args) ; new ring_prev_launcher_id
                        ; we're spending/announcing
                        (sha256 ONE RING_PREV_LAUNCHER_ID)
                      )
                    )
    parent_id (if (not lineage_proof)
      ; this is eve spend, assert launcher id
      LAUNCHER_ID
      ; non-eve spend, assert parent id
      (calculate-coin-id
        (f lineage_proof) ; parent parent id
        (curry_hashes CAT_MOD_HASH
          (sha256 ONE CAT_MOD_HASH)
          (sha256 ONE byc_tail_hash)
          (curry_hashes MOD_HASH ; puzzle hash
            (sha256 ONE MOD_HASH)
            statutes_struct_hash
            (sha256 ONE LAUNCHER_ID)
            (sha256 ONE (if (l (r lineage_proof))
                (f (r lineage_proof))
                RING_PREV_LAUNCHER_ID
              ) ; parent ring_prev_launcher_id
            ) 
          )
        )
        (if (l (r lineage_proof))
          current_amount
          (r lineage_proof)
        ) ; parent amount
      )
    )
    new_amount (if (l args)
      (f (r (r (r (r (r args))))))
      current_amount
    )
    conditions (c
      ; create child treasury coin
      (list CREATE_COIN new_puzzle_hash new_amount)
      filtered_conditions
    )
    withdraw_amount (
      if (> current_amount new_amount)
          (- current_amount new_amount)
        0
    )
    (assert
      ; can't go into negative
      (> new_amount MINUS_ONE) (> withdraw_amount MINUS_ONE)
      (any
       ; we can't leave any change if withdrawing
       (= current_amount (+ new_amount withdraw_amount))
       ; or if depositing must be higher than previous value
       (all (= withdraw_amount 0) (> new_amount current_amount))
      )
      ; we can't do both a withdrawal and a deposit at the same time
      (not (all (> withdraw_amount 0) (> new_amount current_amount)))
      ; must have at least one condition
      (l conditions)
      ; ---- all asserts passed, return conditions
      (c
        (list ASSERT_MY_AMOUNT current_amount)
        (c
          (list ASSERT_MY_PUZZLE_HASH
            (curry_hashes
              CAT_MOD_HASH
              (sha256 ONE CAT_MOD_HASH)
              (sha256 ONE byc_tail_hash)
              (curry_hashes
                MOD_HASH
                (sha256 ONE MOD_HASH)
                statutes_struct_hash
                (sha256 ONE LAUNCHER_ID)
                (sha256 ONE RING_PREV_LAUNCHER_ID)
              )
            )
          )
          (c
            (list ASSERT_MY_PARENT_ID parent_id)
            (if (any (not (l args)) (not lineage_proof))
              ; change ring ordering, require approval from statutes custom condition
              (assert
                (= withdraw_amount 0)
                (size_b32 args)
                (c
                  (list RECEIVE_MESSAGE 0x12
                    (concat
                      PROTOCOL_PREFIX
                      CUSTOM_CONDITION_PREFIX
                      (sha256tree
                        (c LAUNCHER_ID
                          args ; new ring_prev_launcher_id
                        )
                      )
                    )
                    statutes_puzzle_hash
                  )
                  (c
                    (list REMARK PROTOCOL_PREFIX new_amount LAUNCHER_ID args) ; for driver code
                    conditions
                  )
                )
              )
              ; ELSE we're spending/announcing, require approval mods
              (assign
                (
                  approver_parent_id
                  approver_mod_hash
                  approver_mod_curried_args_hash
                  approver_amount
                  approval_mod_hashes
                  _ ; new_amount extracted above
                ) args
                approver_coin_id (assert
                  (size_b32 approver_parent_id)
                  (size_b32 approver_mod_hash)
                  (size_uint64 approver_amount)
                  ; check that this approver mod hash is allowed
                  (contains approval_mod_hashes approver_mod_hash)
                  (calculate-coin-id
                    approver_parent_id
                    ; we want to ensure that the approver puzzle is using the correct mod
                    (if (l approver_mod_curried_args_hash)
                      ; this puzzle is wrapped inside a CAT puzzle, it'll provide a tail too
                      (assert
                        (size_b32 (f (r approver_mod_curried_args_hash)))
                        (size_b32 (f approver_mod_curried_args_hash))
                        (curry_hashes CAT_MOD_HASH
                          (sha256 ONE CAT_MOD_HASH)
                          (sha256 ONE (f approver_mod_curried_args_hash))
                          (tree_hash_of_apply approver_mod_hash (f (r approver_mod_curried_args_hash)))
                        )
                      )
                      ; ELSE puzzle is not wrapped
                      (assert (size_b32 approver_mod_curried_args_hash)
                        (tree_hash_of_apply approver_mod_hash approver_mod_curried_args_hash)
                      )
                    )
                    approver_amount
                  )
                )
          
                (c
                  ; assert approver coin announcement is valid
                  (list RECEIVE_MESSAGE 0x3f
                    (concat
                      PROTOCOL_PREFIX
                      (sha256tree (c (- new_amount current_amount) new_amount))
                    )
                    approver_coin_id
                  )
                  ; assert that approval mod hashes are valid
                  (c (assert-statute statutes_puzzle_hash STATUTE_APPROVAL_MOD_HASHES_HASH (sha256tree approval_mod_hashes))
                    (c
                      ;  my new balance so someone can check whole ring balance
                      (list CREATE_COIN_ANNOUNCEMENT
                        (concat
                          PROTOCOL_PREFIX
                          (sha256tree (c new_amount LAUNCHER_ID))
                        )
                      )
                      (c
                        (list REMARK PROTOCOL_PREFIX new_amount LAUNCHER_ID RING_PREV_LAUNCHER_ID) ; for driver code
                        ; in case of surplus auction, assert crt tail hash
                        (if (= (f (r approval_mod_hashes)) approver_mod_hash)
                          (c (assert-statute statutes_puzzle_hash STATUTE_CRT_TAIL_HASH (f approver_mod_curried_args_hash))
                            conditions
                          )
                          conditions
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
