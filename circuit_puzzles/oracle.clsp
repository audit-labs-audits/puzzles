(mod (MUTATION_PROGRAM_HASH MOD_HASH STATUTES_STRUCT ATOM_ANNOUNCER_PUZZLE_HASH PRICES LAST_UPDATED
      ; solution
      (@ oracle_mutation
        (
          oracle_mutation_program
          statutes_inner_puzzle_hash
          m_of_n
          price_updatable_after_seconds
          price_updatable_threshold_percent
          price_expiration_seconds
          announcer_delay
          announcer_deposit
          current_timestamp
          ; price_announcers -> ((inner_puzzle_hash args_hash price))
          price_announcers
        )
      )
      input_announcement_asserts
     )

  (include *standard-cl-23*)
  (include curry.clib)
  (include condition_codes.clib)
  (include statutes_utils.clib)
  (include utils.clib)
  (include oracle.clib)


  (if oracle_mutation
    (assert (= (sha256tree oracle_mutation_program) MUTATION_PROGRAM_HASH)
      (a
        oracle_mutation_program
        (list
          MOD_HASH STATUTES_STRUCT ATOM_ANNOUNCER_PUZZLE_HASH PRICES LAST_UPDATED
          oracle_mutation
          input_announcement_asserts
        )
      )
    )

    ; no updates, just assert and announce
    ; recreate yourself to conserve updates so far
    (verify-announcement-asserts
      input_announcement_asserts
      (list
        (list CREATE_COIN
          (curry_hashes MOD_HASH
              (sha256 ONE MOD_HASH)
              (sha256tree STATUTES_STRUCT)
              (sha256 ONE ATOM_ANNOUNCER_PUZZLE_HASH)
              (sha256tree PRICES)
              (sha256 ONE LAST_UPDATED)
          )
          ; min singleton amount, force it to be this
          ONE
        )
        (assign
          (last_price . last_updated) (f (cut-prices PRICES 0))
          (list CREATE_PUZZLE_ANNOUNCEMENT (sha256 last_price last_updated))
        )
        (assign
          (last_price . last_updated) (f (cut-prices PRICES 0))
          (list REMARK last_price last_updated)
        )
      )
    )
  )
)
