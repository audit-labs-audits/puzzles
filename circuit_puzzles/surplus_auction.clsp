(mod (MOD_HASH
      CAT_MOD_HASH
      STATUTES_STRUCT ; to assert statutes
      LAUNCHER_ID ; to assert uniqueness of launcher_id
      CAT_LOT_AMOUNT ; amount of BYC in a lot to win
      CAT_TAIL_HASH ; hash of BYC tail puzzle that we're giving out
      CRT_TAIL_HASH ; hash of CRT tail puzzle that we're giving out
      LAST_BID ; to hold bid data -> (bid_crt_amount bid_coin_parent_id target_puzzle_hash current_timestamp)
      statutes_inner_puzzle_hash
      lineage_proof ; (parent_id launcher_id amount last_bid)
      op_code . op_args)

  (include *standard-cl-23*)
  (include curry.clib)
  (include condition_codes.clib)
  (include sha256tree.clib)
  (include statutes_utils.clib)
  (include utils.clib)

  (defconst TREASURY_COIN_ANN_PREFIX 0x24) ; -> '$'
  (defconst ANN_PREFIX '^')
  (defconst START_AUCTION 1)
  (defconst BID 2)
  (defconst WIN 3) ; NOTE: this also melts the coin

    (defun merge-lists (list_a list_b)
      (if list_a
          (c (f list_a) (merge-lists (r list_a) list_b))
          list_b
      )
    )

   (defun assert_ (items)
    (if (r items)
      (qq (if (unquote (f items)) (unquote (assert_ (r items))) (x (unquote (c 1 (f items))))))
      (f items)
      )
    )

  (defmac assert items (assert_ items))

  (defun assert-treasury-coins-withdrawal (P2_TREASURY_HASH CAT_MOD_HASH CAT_TAIL_HASH STATUTES_STRUCT treasury_maximum statutes_puzzle_hash
                                           treasury_coins my_coin_id lot_amount sum_amount CAT_leftover announcements)
    ; treasury_coins -> ((leader_launcher_1 . amount1) (launcher_2 . amount2)...)
    ; sorted in reverse order as we have no have to go backwards in a list
    ; we iterate over them extracting launcher id and previous launcher id to
    ; form a puzzle hash of each treasury coin in a ring. Amount should form a sum
    ; of lot amount needed for this surplus auction
    (if treasury_coins
      (assign
        ; treasury_coin -> (parent_id launcher_id current_amount withdraw_amount)
        (parent_id launcher_id prev_launcher_id current_amount withdraw_amount) (f treasury_coins)
        treasury_coin_id (
          calculate-coin-id
            parent_id
            (curry_hashes CAT_MOD_HASH
              (sha256tree CAT_MOD_HASH)
              (sha256tree CAT_TAIL_HASH)
              (curry_hashes
                P2_TREASURY_HASH
                (sha256tree P2_TREASURY_HASH)
                (sha256tree CAT_MOD_HASH)
                (sha256tree CAT_TAIL_HASH)
                (sha256tree STATUTES_STRUCT)
                (sha256tree prev_launcher_id)
                (sha256tree launcher_id)
              )
            )
            current_amount ; taking second of (launcher_id amount) pair
        )
        (c
          (list ASSERT_COIN_ANNOUNCEMENT
            (sha256
              treasury_coin_id
              TREASURY_COIN_ANN_PREFIX
              my_coin_id
              (* -1 withdraw_amount)
              (- current_amount withdraw_amount)
            )
          )
          (c
            ; we also create a coin announcement for each treasury coin
            (list CREATE_COIN_ANNOUNCEMENT
              (concat
                ANN_PREFIX
                treasury_coin_id
                (* -1 withdraw_amount)
                (- current_amount withdraw_amount)
              )
            )
            (assert-treasury-coins-withdrawal
              P2_TREASURY_HASH CAT_MOD_HASH CAT_TAIL_HASH STATUTES_STRUCT treasury_maximum statutes_puzzle_hash
              (r treasury_coins)
              my_coin_id
              lot_amount
              (+ sum_amount withdraw_amount)
              (- (+ CAT_leftover current_amount) withdraw_amount)
              announcements
            )
          )
        )
      )
      ; we're withdrawing exactly what lot we require for this surplus auction
      ; and treasury needs to stay above maximum threshold, so to trigger surplus auction
      ; we need maximum + lot_amount
      (assert (= sum_amount lot_amount) (> CAT_leftover treasury_maximum)
        (c
          (assert-statute statutes_puzzle_hash STATUTE_TREASURY_MAXIMUM treasury_maximum) ; end of recursion
          announcements
        )
      )
    )
  )
  (defun filter-announcements ((@ conditions ( (condition_code . condition_rest) . rest_of_conditions)) filtered_announcements)
    (if conditions
      (if (any (= condition_code CREATE_PUZZLE_ANNOUNCEMENT) (= condition_code CREATE_COIN_ANNOUNCEMENT))
        (if (not
              (= (substr (f condition_rest) 0 1) ANN_PREFIX)
            )
          (filter-announcements
            rest_of_conditions
            (c (f conditions) filtered_announcements)
          )
          ; bad announcement found, error
          (x)
        )
        (if (any (= condition_code ASSERT_COIN_ANNOUNCEMENT) (= condition_code ASSERT_PUZZLE_ANNOUNCEMENT))
          (filter-announcements
            rest_of_conditions
            (c (f conditions) filtered_announcements)
          )
          ; no other conditions please
          (x)
        )
      )
      filtered_announcements
    )
  )


  (assign
    recreate-coin (lambda ((& MOD_HASH CAT_MOD_HASH CAT_TAIL_HASH
                              CRT_TAIL_HASH STATUTES_STRUCT)
                           launcher_id bid lot_amount amount)
      (list
        CREATE_COIN
        (curry_hashes
          MOD_HASH
          (sha256tree MOD_HASH)
          (sha256tree CAT_MOD_HASH)
          (sha256tree STATUTES_STRUCT)
          (sha256tree launcher_id)
          (sha256tree lot_amount)
          (sha256tree CAT_TAIL_HASH)
          (sha256tree CRT_TAIL_HASH)
          (sha256tree bid)
        )
        amount
      )
    )
    statutes_puzzle_hash (calculate-statutes-puzzle-hash STATUTES_STRUCT statutes_inner_puzzle_hash)
    (if (= op_code START_AUCTION)
      (assign
        (p2_surplus_auction_coin_parent_id lot_amount p2_surplus_auction_mod_hash p2_treasury_hash
        start_time my_coin_id treasury_coins treasury_maximum raw_announcements) op_args
        announcements (filter-announcements raw_announcements ())
        p2_surplus_puzzle_hash (
          curry_hashes CAT_MOD_HASH
            (sha256tree CAT_MOD_HASH)
            (sha256tree CAT_TAIL_HASH)
            (curry_hashes p2_surplus_auction_mod_hash
              (sha256tree p2_surplus_auction_mod_hash)
              (sha256tree CAT_MOD_HASH)
              (sha256tree CAT_TAIL_HASH)
              (sha256tree CRT_TAIL_HASH)
              (sha256tree MOD_HASH)
              (sha256tree my_coin_id)
            )
        )
        p2_surplus_auction_coin_id (calculate-coin-id
            p2_surplus_auction_coin_parent_id
            p2_surplus_puzzle_hash
            0 ; initial amount for the coin that holds our lot should be 0
        )
        (assert
          ; can't run if LAST_BID is set
          (= LAST_BID ())
          ; we can only run if launcher_id is not set
          ; since we'll be using current coin id as launcher id
          ; to guarantee uniqueness based on the amount we're taking from treasury
          ; ie: there's a limited amount that can be taken from treasury
          ;     and coin_id is unique per spend. Once this coin is filled from treasury
          ;     it can't be filled again, hence can be used as unique event in this coins history
          (= LAUNCHER_ID 0)
          (= CAT_LOT_AMOUNT 0)
          (c
            ; recreate itself setting the launcher_id, empty bid and coin amount is 0
            (a recreate-coin (list my_coin_id () lot_amount 0))
            (c
              (list ASSERT_MY_AMOUNT 0)
              (c
                (list ASSERT_MY_COIN_ID my_coin_id)
                (c
                  (assert-statute statutes_puzzle_hash STATUTE_SURPLUS_AUCTION_LOT_AMOUNT lot_amount)
                  (c
                    (assert-statute statutes_puzzle_hash STATUTE_P2_TREASURY_MOD_HASH p2_treasury_hash)
                    (c
                      (assert-statute statutes_puzzle_hash STATUTE_P2_SURPLUS_AUCTION_MOD_HASH p2_surplus_auction_mod_hash)
                      ; start_time minus one tx block time should already be in the past
                      (c (list ASSERT_SECONDS_ABSOLUTE (- start_time 55))
                        ; make sure that start_time hasn't happen yet, allow it to be in mempool for 5 tx blocks
                        (c (list ASSERT_BEFORE_SECONDS_ABSOLUTE (+ start_time (* 5 55)))
                          ; assert p2_surplus_auction coin received the lot amount
                          (c (list CREATE_COIN_ANNOUNCEMENT (concat p2_surplus_auction_coin_id lot_amount ()))
                            (c (list ASSERT_COIN_ANNOUNCEMENT (sha256 p2_surplus_auction_coin_id my_coin_id lot_amount ()))
                              (c (list REMARK my_coin_id lot_amount 0 () CAT_TAIL_HASH CRT_TAIL_HASH)
                                (assert-treasury-coins-withdrawal
                                  p2_treasury_hash
                                  CAT_MOD_HASH
                                  CAT_TAIL_HASH
                                  STATUTES_STRUCT
                                  treasury_maximum
                                  statutes_puzzle_hash
                                  treasury_coins
                                  my_coin_id
                                  lot_amount ; lot amount of byc offered
                                  0 ; withdrawal sum amount
                                  0 ; leftover byc amount
                                  announcements
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
      (if (= op_code BID)
        (assign
          ; op_args -> (bid_crt_amount target_puzzle_hash timestamp)
          (bid_crt_amount target_puzzle_hash current_timestamp my_amount ttl my_coin_id
          offer_mod_hash lot_amount raw_announcements) op_args
          (last_target_puzzle_hash last_bid_timestamp) (if LAST_BID LAST_BID (list 0 0))
          announcements (filter-announcements raw_announcements ())
          bid_conditions ( assert
            ; we need lineage proof to ensure that a CAT lot is associated with this surplus auction
            (l lineage_proof)
            ; ensure bidder is aware what they bidding for, this might be different if lot amount changes while auction
            ; is running, so we're double checking it here to make sure that bidder is aware of the current lot amount
            (= lot_amount CAT_LOT_AMOUNT)
            ; must be higher than current bid (keepers are bidding for smallest amount of CRT per BYC lot)
            (any (all (= my_amount 0) (> bid_crt_amount 0)) (> bid_crt_amount my_amount))
            ; TTL for bid hasn't expired yet
            (any (not last_bid_timestamp) (> ttl (- current_timestamp last_bid_timestamp)))
            (c
              (list ASSERT_MY_AMOUNT my_amount)
                ; recreate with new top bid and new timestamp
              (c
                (a
                  recreate-coin
                  (list
                    LAUNCHER_ID
                    (list target_puzzle_hash current_timestamp)
                    lot_amount
                    bid_crt_amount
                  )
                )
                (c
                  (list REMARK LAUNCHER_ID lot_amount bid_crt_amount (list target_puzzle_hash current_timestamp) CAT_TAIL_HASH CRT_TAIL_HASH)
                  (c
                    (assert-statute statutes_puzzle_hash STATUTE_SURPLUS_AUCTION_BID_TTL ttl)
                    (c
                      (assert-statute statutes_puzzle_hash STATUTE_OFFER_MOD_HASH offer_mod_hash)
                      ; current_time minus one tx block time should already be in the past
                      (c
                        (list ASSERT_SECONDS_ABSOLUTE (- current_timestamp 55))
                        (c
                          ; make sure that current_timestamp hasn't happen yet, allow it to be in mempool for 5 tx blocks
                          (list ASSERT_BEFORE_SECONDS_ABSOLUTE (+ current_timestamp (* 5 55)))
                          (c
                            (list ASSERT_MY_COIN_ID my_coin_id)
                            ; ensure lineage so we don't lose track of the lot
                            (c
                              (list ASSERT_MY_PARENT_ID
                                (sha256
                                  (f lineage_proof)
                                  (curry_hashes
                                    CAT_MOD_HASH
                                    (sha256tree CAT_MOD_HASH)
                                    (sha256tree CRT_TAIL_HASH)
                                    (curry_hashes MOD_HASH
                                      (sha256tree MOD_HASH)
                                      (sha256tree CAT_MOD_HASH)
                                      (sha256tree STATUTES_STRUCT)
                                      (sha256tree (f (r (r lineage_proof)))) ; launcher id
                                      (sha256tree (f (r (r (r lineage_proof))))) ; lot amount
                                      (sha256tree CAT_TAIL_HASH)
                                      (sha256tree CRT_TAIL_HASH)
                                      (sha256tree (f (r (r (r (r lineage_proof)))))) ; last bid
                                    )
                                  )
                                  ; parent bid amount
                                  (f (r lineage_proof))
                                )
                              )
                              announcements
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
          (if last_target_puzzle_hash
            (c
              ; assert that keeper absorbed their collateral + left over mojos from melting
              (list ASSERT_PUZZLE_ANNOUNCEMENT
                (sha256
                  (curry_hashes CAT_MOD_HASH
                    (sha256tree CAT_MOD_HASH)
                    (sha256tree CRT_TAIL_HASH)
                    offer_mod_hash
                  )
                  (sha256tree
                    (c my_coin_id
                      (list
                        (list last_target_puzzle_hash my_amount (list last_target_puzzle_hash))
                      )
                    )
                  )
                )
              )
              bid_conditions
            )
            bid_conditions
          )
        )
        (if (= op_code WIN)
          ; we have a winning bid, we're going to melt ourselves and transfer BYC
          ; from p2_surplus_auction coin to the winner
          ; op_args -> (ttl auction_timeout)
          (assign
            (target_puzzle_hash timestamp) LAST_BID
            (ttl current_timestamp my_amount crt_tail_puzzle p2_surplus_auction_coin_parent_id
             my_coin_id p2_surplus_auction_hash lot_amount limitation_solution raw_announcements) op_args
            crt_tail_hash (sha256tree crt_tail_puzzle)
            announcements (filter-announcements raw_announcements ())
            p2_surplus_puzzle_hash (
              curry_hashes CAT_MOD_HASH
                (sha256tree CAT_MOD_HASH)
                (sha256tree CAT_TAIL_HASH)
                (curry_hashes p2_surplus_auction_hash
                  (sha256tree p2_surplus_auction_hash)
                  (sha256tree CAT_MOD_HASH)
                  (sha256tree CAT_TAIL_HASH)
                  (sha256tree CRT_TAIL_HASH)
                  (sha256tree MOD_HASH)
                  (sha256tree LAUNCHER_ID)
                )
            )
            p2_surplus_auction_coin_id (calculate-coin-id
                p2_surplus_auction_coin_parent_id
                p2_surplus_puzzle_hash
                CAT_LOT_AMOUNT
            )
            conditions (assert
              ; ensure correct tail reveal is passed
              (= crt_tail_hash CRT_TAIL_HASH)
              ; ttl should've expired
              (> (- current_timestamp timestamp) ttl)
              ; check lot matches
              (= lot_amount CAT_LOT_AMOUNT)
              (list
                (list ASSERT_MY_AMOUNT my_amount)
                ; no recreate here, we create melting condition
                (list CREATE_COIN 0 -113 crt_tail_puzzle limitation_solution)
                (assert-statute statutes_puzzle_hash STATUTE_SURPLUS_AUCTION_BID_TTL ttl)
                (assert-statute statutes_puzzle_hash STATUTE_P2_SURPLUS_AUCTION_MOD_HASH p2_surplus_auction_hash)
                ; current_time minus one tx block time should already be in the past
                (list ASSERT_SECONDS_ABSOLUTE (- current_timestamp 55))
                ; make sure that current_timestamp hasn't happen yet, allow it to be in mempool for 5 tx blocks
                (list ASSERT_BEFORE_SECONDS_ABSOLUTE (+ current_timestamp (* 5 55)))
                ; assert p2_surplus_auction coin transferred the lot amount to the winner (target_puzzle_hash)
                (list CREATE_COIN_ANNOUNCEMENT (concat LAUNCHER_ID lot_amount target_puzzle_hash))
                (list ASSERT_COIN_ANNOUNCEMENT (sha256 p2_surplus_auction_coin_id my_coin_id LAUNCHER_ID lot_amount target_puzzle_hash))
                ; ensure lineage so nobody can fake the winning bid
                (list ASSERT_MY_PARENT_ID
                  (sha256
                    (f lineage_proof)
                    (curry_hashes
                      CAT_MOD_HASH
                      (sha256tree CAT_MOD_HASH)
                      (sha256tree CRT_TAIL_HASH)
                      (curry_hashes MOD_HASH
                        (sha256tree MOD_HASH)
                        (sha256tree CAT_MOD_HASH)
                        (sha256tree STATUTES_STRUCT)
                        (sha256tree (f (r (r lineage_proof))))
                        (sha256tree (f (r (r (r lineage_proof)))))
                        (sha256tree CAT_TAIL_HASH)
                        (sha256tree CRT_TAIL_HASH)
                        (sha256tree (f (r (r (r (r lineage_proof))))))
                      )
                    )
                    ; parent bid amount
                    (f (r lineage_proof))
                  )
                )
              )
            )
            (if announcements
              ; FIXME: use cons, not merge-lists
              (merge-lists conditions announcements)
              conditions
            )
          )
          (x "unknown op_code" op_code)
        )
      )
    )
  )
)